/**
 * \author Dan Keefe (dfk)
 *
 * \file  HybridDrawHCI.H
 * \brief
 *
 */


#ifndef HYBRIDDRAWHCI_H
#define HYBRIDDRAWHCI_H

//#include "VRBase.H"
#include <GfxMgr.H>
#include <EventMgr.H>
#include "BrushState.H"
#include "CavePaintingCursors.H"
#include "HCIMgr.H"

namespace DrawOnAir {

typedef G3D::ReferenceCountedPointer<class HybridDrawHCI> HybridDrawHCIRef;
/** Interface for brush input mapped directly from EventCoordinateFrames
    usually generated by a 6DOF device to creating a Mark.
*/
class HybridDrawHCI : public StylusHCI
{
public:
  HybridDrawHCI(G3D::Array<std::string>     brushOnTriggers,
                G3D::Array<std::string>     brushMotionTriggers, 
                G3D::Array<std::string>     brushOffTriggers,
                G3D::Array<std::string>     handMotionTriggers, 
                G3D::Array<std::string>     handOnTriggers, 
                G3D::Array<std::string>     handOffTriggers, 
                BrushRef               brush,
                CavePaintingCursorsRef cursors,
                MinVR::EventMgrRef            eventMgr,
    MinVR::GfxMgrRef              gfxMgr);
  virtual ~HybridDrawHCI();

  void setEnabled(bool b);
  bool canReleaseFocus();

  void setLineLength(double d);

  void toggleConstantDragLengthDisplay() { 
    _dispConstLenDragLine = !_dispConstLenDragLine;
  }

  // interactor methods
  void brushMotion(MinVR::EventRef e);
  void brushOn(MinVR::EventRef e);
  void brushPressureChange(MinVR::EventRef e);
  void brushOff(MinVR::EventRef e);
  void handMotion(MinVR::EventRef e);
  void headMotion(MinVR::EventRef e);
  void dragMotion(MinVR::EventRef e);
  void tapeMotion(MinVR::EventRef e);
  void dragToTape(MinVR::EventRef e);
  void tapeToDrag(MinVR::EventRef e);

  void draw(G3D::RenderDevice *rd, const G3D::CoordinateFrame &virtualToRoomSpace);

protected:
  BrushRef               _brush;
  CavePaintingCursorsRef _cursors;
  MinVR::EventMgrRef            _eventMgr;
  MinVR::FsaRef                 _fsa;
  MinVR::GfxMgrRef              _gfxMgr;
  bool                   _enabled;
  int                    _drawID;
  double                 _lineLength;
  double                 _interpLineLength;
  double                 _initLineLength;
  double                 _pathLength;
  G3D::CoordinateFrame        _dragFrame;
  G3D::CoordinateFrame        _brushFrame;
  G3D::Vector3                _handPos;
  G3D::Vector3                _handOffset;
  G3D::Vector3                _brushOffset;
  G3D::Vector3                _lastPointOnPath;
  G3D::Array<G3D::Vector3>         _markPath;
  bool                   _reverse;
  G3D::Vector3                _lastBrushPos;
  bool                   _dispConstLenDragLine;

private:
  HybridDrawHCI(const HybridDrawHCI &);
  HybridDrawHCI& operator=(const HybridDrawHCI &);
};


} // end namespace
#endif
